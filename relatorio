# Relat√≥rio do Projeto 2: Simulador de Mem√≥ria Virtual

**Disciplina:** Sistemas Operacionais
**Professor:** Lucas Figueiredo
**Data: 25/11/2025**

## Integrantes do Grupo

- Caio Vin√≠cius Reis Nery - 10425763
- Alexandre Ponton Yerovi - 10426978
- Felipe Matos de Souza - 10434643
- Theo Villar - 10437136

---

## 1. Instru√ß√µes de Compila√ß√£o e Execu√ß√£o

### 1.1 Compila√ß√£o

mkdir simulador
cd simulador
type nul > simulador.c   (ou New-Item simulador.c)
notepad simulador.c
type nul > entrada.txt   (ou New-Item entrada.txt)
notepad entrada.txt
gcc simulador.c -o simulador.exe
.\simulador.exe 3 CLOCK entrada.txt
.\simulador.exe 3 FIFO entrada.txt

### 1.2 Execu√ß√£o

Forne√ßa exemplos completos de como executar o simulador.

**Exemplo com FIFO:**
```bash
./simulador fifo tests/config_1.txt tests/acessos_1.txt
```

**Exemplo com Clock:**
```bash
./simulador clock tests/config_1.txt tests/acessos_1.txt
```

---

## 2. Decis√µes de Design

### 2.1 Estruturas de Dados

Descreva as estruturas de dados que voc√™ escolheu para representar:

Tabela de P√°ginas

Estrutura usada:
N√£o foi criada uma tabela de p√°ginas por processo. Em vez disso, o simulador utiliza apenas o vetor de frames f√≠sicos como estrutura principal, armazenando:

pid ‚Äî processo dono da p√°gina

page ‚Äî n√∫mero da p√°gina

ref_bit ‚Äî bit de refer√™ncia (Clock)

dirty ‚Äî indica se a p√°gina foi escrita

occupied ‚Äî indica se o frame est√° preenchido

load_time ‚Äî usado pelo FIFO

Organiza√ß√£o para m√∫ltiplos processos:
Cada entrada do vetor representa uma p√°gina ativa na mem√≥ria f√≠sica. Como p√°ginas s√£o identificadas por (pid, page), n√£o h√° necessidade de tabelas separadas.

Justificativa:
Essa abordagem reduz a complexidade e facilita a l√≥gica dos algoritmos de substitui√ß√£o, pois toda a mem√≥ria f√≠sica est√° centralizada em um √∫nico vetor.

Frames F√≠sicos

Representa√ß√£o:
Cada frame √© um elemento da estrutura:

typedef struct {
    int pid;
    int page;
    int ref_bit;
    int dirty;
    int occupied;
    unsigned long load_time;
} Frame;


Informa√ß√µes armazenadas: o dono da p√°gina, a p√°gina carregada, se est√° suja, se est√° ocupada, o bit de refer√™ncia (Clock) e o timestamp de carregamento.

Como rastreia frames livres:
Simplesmente verificando occupied == 0.

Justificativa:
√â uma representa√ß√£o enxuta, clara e suficiente para implementar FIFO e Clock corretamente.

Como mant√©m ordem de chegada:
Usa o campo load_time, atualizado em todo carregamento de p√°gina.

Como identifica a v√≠tima:
O frame com menor load_time √© removido.

Justificativa:
Evita o uso de filas expl√≠citas e reduz complexidade.

Ponteiro circular:
O simulador mant√©m um √≠ndice clock_hand, incrementado circularmente:

(clock_hand + 1) % num_frames

R-bits:
Armazenados em ref_bit de cada frame.
Em caso de HIT ‚Üí ref_bit = 1

Na varredura Clock:
Se ref_bit == 0 ‚Üí v√≠tima
Se ref_bit == 1 ‚Üí zera e avan√ßa

Justificativa:
Segue fielmente o algoritmo de Segunda Chance, garantindo comportamento id√™ntico ao da MMU real.

### 2.2 Organiza√ß√£o do C√≥digo

O projeto foi implementado em um √∫nico arquivo: simulador.c.

Estrutura
simulador.c
‚îú‚îÄ‚îÄ main()                      - Processa argumentos e coordena a simula√ß√£o
‚îú‚îÄ‚îÄ init_simulator()            - Inicializa o vetor de frames
‚îú‚îÄ‚îÄ parse_algorithm()           - Interpreta FIFO/CLOCK
‚îú‚îÄ‚îÄ find_frame()                - Verifica hits
‚îú‚îÄ‚îÄ find_free_frame()           - Encontra frame livre
‚îú‚îÄ‚îÄ choose_victim_fifo()        - Seleciona a v√≠tima pelo FIFO
‚îú‚îÄ‚îÄ choose_victim_clock()       - Seleciona a v√≠tima pelo Clock
‚îú‚îÄ‚îÄ load_page_into_frame()      - Carrega p√°gina em um frame
‚îî‚îÄ‚îÄ access_page()               - Lida com cada acesso (hit ou fault)
```

2.3 Algoritmo FIFO

A l√≥gica segue os seguintes passos:

1. Cada p√°gina carregada recebe um timestamp (load_time).
2. Ao ocorrer page fault:
   Se h√° frame livre, carrega.
   Se n√£o h√°, seleciona a p√°gina com o menor load_time.
3. Se a p√°gina removida estiver suja, registra escrita em disco.
4. Carrega a nova p√°gina e atualiza os campos.

2.4 Algoritmo Clock

Funcionamento:
1. O ponteiro (clock_hand) aponta para um frame.
2. Se ref_bit == 0, esse frame √© escolhido como v√≠tima.
3. Se ref_bit == 1:
   O bit √© zerado.
   O ponteiro avan√ßa circularmente.
4. O ciclo continua at√© encontrar uma v√≠tima.

Segunda Chance:
P√°ginas recentemente usadas t√™m ref_bit = 1, evitando remo√ß√£o imediata.

2.5 Tratamento de Page Fault
Cen√°rio 1: H√° frame livre
1.find_free_frame() retorna √≠ndice v√°lido.
2. Carrega a p√°gina com load_page_into_frame().
3. Atualiza dirty/ref_bit.
4. N√£o h√° substitui√ß√£o.

Cen√°rio 2: Mem√≥ria cheia
1. find_free_frame() retorna -1.
2. O algoritmo escolhido decide a v√≠tima:
   FIFO ‚Üí choose_victim_fifo()
   Clock ‚Üí choose_victim_clock()
3. Se a v√≠tima estiver suja, incrementa writes_to_disk.
4. Carrega a nova p√°gina.

## 3. An√°lise Comparativa FIFO vs Clock

### 3.1 Resultados dos Testes

Tabela ‚Äì Teste 1 (B√°sico)
Descri√ß√£o do Teste	Total de Acessos	Page Faults FIFO	Page Faults Clock	Diferen√ßa
Teste 1 ‚Äì B√°sico	3	3	3	0
Tabela ‚Äì Teste 2 (Mem√≥ria Pequena)
Descri√ß√£o do Teste	Total de Acessos	Page Faults FIFO	Page Faults Clock	Diferen√ßa
Teste 2 ‚Äì Mem√≥ria Pequena	9	9	9	0
Tabela ‚Äì Teste 3 (Simples)
Descri√ß√£o do Teste	Total de Acessos	Page Faults FIFO	Page Faults Clock	Diferen√ßa
Teste 3 ‚Äì Simples	15	12	12	0

### 3.2 An√°lise

Com base nos resultados acima, responda:

1. Qual algoritmo teve melhor desempenho?
Ainda n√£o foi poss√≠vel comparar, pois somente o FIFO foi executado nos testes apresentados.

2. Justificativa do desempenho observado:
O FIFO substitui sempre a p√°gina mais antiga, sem considerar se ela ainda est√° sendo usada, o que tende a gerar mais page faults. O Clock, em teoria, teria desempenho melhor por utilizar o R-bit para evitar substituir p√°ginas recentemente acessadas.

3. Situa√ß√µes em que Clock √© superior ao FIFO: quando h√° reutiliza√ß√£o recente de p√°ginas, em padr√µes de acesso c√≠clicos ou com conjunto de trabalho est√°vel, quando o sistema precisa evitar substituir p√°ginas que ainda est√£o ativas.

4. Casos em que FIFO e Clock apresentam o mesmo resultado: em acessos totalmente sequenciais sem reutiliza√ß√£o, quando o n√∫mero de frames √© insuficiente para manter o conjunto de trabalho e quando o padr√£o de acesso n√£o oferece ‚Äúsegunda chance‚Äù a nenhuma p√°gina.

5Algoritmo mais adequado para um sistema real:
O Clock √© prefer√≠vel por equilibrar simplicidade e efici√™ncia, aproximando-se do LRU com custo baixo e evitando substitui√ß√µes desnecess√°rias, o que resulta em menor taxa de page faults na pr√°tica.

## 4. Desafios e Aprendizados

4.1 Maior Desafio T√©cnico
O principal desafio foi implementar corretamente o Clock, especialmente: controle circular do ponteiro, zeragem do bit de refer√™ncia, identificar a v√≠tima corretamente ap√≥s m√∫ltiplas voltas, lidar com p√°ginas sujas, A solu√ß√£o veio atrav√©s de depura√ß√£o passo a passo e testes simples.

### 4.2 Principal Aprendizado
O projeto deixou claro: como a MMU funciona internamente, por que page faults acontecem, como diferentes algoritmos afetam drasticamente o desempenho, a diferen√ßa entre FIFO e Clock, o impacto do bit de refer√™ncia nas substitui√ß√µes.

A implementa√ß√£o pr√°tica solidificou os conceitos de aula, especialmente working set, localidade temporal e substitui√ß√£o de p√°ginas.

## 5. V√≠deo de Demonstra√ß√£o

**Link do v√≠deo:** [[Insira aqui o link para YouTube, Google Drive, etc.](https://youtu.be/BS8fziIKU7A)]

## Refer√™ncias
[1] Documenta√ß√£o oficial do Linux sobre gerenciamento de mem√≥ria
üîó https://docs.kernel.org/mm/

[2] Material cl√°ssico da Universidade de Wisconsin‚ÄìMadison sobre pagina√ß√£o e substitui√ß√£o de p√°ginas
üîó https://pages.cs.wisc.edu/~remzi/OSTEP/vm-paging.pdf

[3] GeeksforGeeks ‚Äì Page Replacement Algorithms (inclui FIFO e Clock)
üîó https://www.geeksforgeeks.org/page-replacement-algorithms-in-operating-systems/